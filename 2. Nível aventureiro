#include <stdio.h>
#include <stdlib.h> // Para malloc, calloc, free, rand, srand
#include <string.h> // Para strcpy, strcmp
#include <time.h>   // Para time()

// --- Struct Atualizada ---
// Define a estrutura de dados para cada território do jogo.
struct Territorio {
    char nome[30];
    char cor[10];
    int tropas;
};

// --- Protótipos das Funções Modulares ---
void cadastrarTerritorios(struct Territorio *mapa, int tam);
void exibirMapa(struct Territorio *mapa, int tam);
void atacar(struct Territorio *atacante, struct Territorio *defensor);
void liberarMemoria(struct Territorio *mapa);

int main() {
    // Inicializa o gerador de números aleatórios. Deve ser feito apenas uma vez.
    srand(time(NULL));

    int numTerritorios;
    printf("=============================================\n");
    printf("      BEM-VINDO AO JOGO WAR ESTRUTURADO\n");
    printf("=============================================\n\n");

    // --- Alocação de Memória Dinâmica ---
    printf("Digite o numero total de territorios no mapa: ");
    scanf("%d", &numTerritorios);

    // Aloca memória para o vetor de territórios usando calloc.
    // calloc é útil pois inicializa a memória alocada com zeros.
    struct Territorio *mapaMundi = (struct Territorio*) calloc(numTerritorios, sizeof(struct Territorio));

    // Validação de alocação de memória
    if (mapaMundi == NULL) {
        printf("Erro: Falha ao alocar memoria.\n");
        return 1; // Termina o programa com código de erro.
    }

    // --- Cadastro ---
    cadastrarTerritorios(mapaMundi, numTerritorios);

    // --- Loop Principal do Jogo (Ataques) ---
    int opcao = 1;
    while (opcao != 0) {
        exibirMapa(mapaMundi, numTerritorios);

        int idxAtacante, idxDefensor;
        printf("\n--- FASE DE ATAQUE ---\n");
        printf("Digite o numero do territorio atacante (ou 0 para sair): ");
        scanf("%d", &idxAtacante);

        if (idxAtacante == 0) break;

        printf("Digite o numero do territorio defensor: ");
        scanf("%d", &idxDefensor);

        // Converte para índice de vetor (subtrai 1)
        idxAtacante--;
        idxDefensor--;

        // --- Validações ---
        if (idxAtacante < 0 || idxAtacante >= numTerritorios || idxDefensor < 0 || idxDefensor >= numTerritorios) {
            printf("\nErro: Numero de territorio invalido!\n\n");
            continue;
        }

        // Ponteiros para os territórios envolvidos na batalha
        struct Territorio *atacante = &mapaMundi[idxAtacante];
        struct Territorio *defensor = &mapaMundi[idxDefensor];

        // Valida se o jogador não está atacando a si mesmo
        if (strcmp(atacante->cor, defensor->cor) == 0) {
            printf("\nErro: Voce nao pode atacar um territorio que ja eh seu!\n\n");
            continue;
        }
        
        // Valida se o atacante tem tropas suficientes para atacar
        if (atacante->tropas <= 1) {
            printf("\nErro: Voce precisa de mais de 1 tropa para atacar!\n\n");
            continue;
        }

        // --- Execução do Ataque ---
        atacar(atacante, defensor);
    }

    // --- Liberação de Memória ---
    liberarMemoria(mapaMundi);

    printf("\nJogo finalizado.\n");
    return 0;
}

/**
 * @brief Cadastra os territórios com dados informados pelo usuário.
 * @param mapa Ponteiro para o vetor de territórios.
 * @param tam Tamanho do vetor.
 */
void cadastrarTerritorios(struct Territorio *mapa, int tam) {
    printf("\n--- FASE DE CADASTRO DE TERRITORIOS ---\n");
    for (int i = 0; i < tam; i++) {
        printf("\n--- Territorio %d ---\n", i + 1);
        printf("Nome: ");
        scanf("%s", (mapa + i)->nome); // Acesso via ponteiro
        printf("Cor do exercito: ");
        scanf("%s", (mapa + i)->cor);
        printf("Numero de tropas: ");
        scanf("%d", &(mapa + i)->tropas);
    }
}

/**
 * @brief Exibe o estado atual de todos os territórios no mapa.
 * @param mapa Ponteiro para o vetor de territórios.
 * @param tam Tamanho do vetor.
 */
void exibirMapa(struct Territorio *mapa, int tam) {
    printf("\n=============================================\n");
    printf("              ESTADO ATUAL DO MAPA\n");
    printf("=============================================\n");
    for (int i = 0; i < tam; i++) {
        // Acesso aos membros da struct via ponteiro e operador '->'
        printf("%d. %s | Exercito: %s | Tropas: %d\n",
               i + 1, (mapa + i)->nome, (mapa + i)->cor, (mapa + i)->tropas);
    }
    printf("=============================================\n");
}

/**
 * @brief Simula um ataque entre dois territórios.
 * @param atacante Ponteiro para o território atacante.
 * @param defensor Ponteiro para o território defensor.
 */
void atacar(struct Territorio* atacante, struct Territorio* defensor) {
    // Simula a rolagem de um dado de 6 faces para cada lado
    int dadoAtaque = (rand() % 6) + 1;
    int dadoDefesa = (rand() % 6) + 1;

    printf("\n--- RESULTADO DA BATALHA ---\n");
    printf("Atacante (%s) rolou: %d\n", atacante->nome, dadoAtaque);
    printf("Defensor (%s) rolou: %d\n", defensor->nome, dadoDefesa);

    // --- Lógica de Batalha e Atualização dos Campos ---
    if (dadoAtaque > dadoDefesa) {
        printf("\n>> VITORIA DO ATACANTE! %s conquistou %s.\n", atacante->nome, defensor->nome);
        
        // Transfere a cor do exército para o território conquistado.
        strcpy(defensor->cor, atacante->cor);

        // Metade das tropas do atacante se movem para o novo território.
        int tropasMovidas = atacante->tropas / 2;
        defensor->tropas = tropasMovidas;
        atacante->tropas -= tropasMovidas;

    } else {
        printf("\n>> VITORIA DA DEFESA! %s repeliu o ataque.\n", defensor->nome);
        
        // O atacante perde 1 tropa como penalidade pela derrota.
        atacante->tropas--;
        printf("O atacante perdeu 1 tropa na batalha.\n");
    }
}

/**
 * @brief Libera a memória alocada dinamicamente para o mapa.
 * @param mapa Ponteiro para o vetor de territórios.
 */
void liberarMemoria(struct Territorio *mapa) {
    printf("\nLiberando memoria alocada...\n");
    free(mapa); // Libera o bloco de memória.
}
